<?php namespace ProcessWire;

/**
 * Process Changelog
 *
 * This module keeps track of changes (edits, additions, removals etc.) on pages of your site. For detailed information
 * and installation instructions see README.md.
 *
 * @copyright 2013-2022 Teppo Koivula
 * @license https://www.gnu.org/licenses/gpl-2.0.txt GNU General Public License, version 2
 */
class ProcessChangelog extends Process implements ConfigurableModule {

    /**
     * Return information about this module (required)
     *
     * @return array
     */
    public static function getModuleInfo() {
        return [
            'title' => __('Changelog'),
            'summary' => __('Keep track of changes (edits, removals, additions etc.)'),
            'href' => 'https://processwire.com/modules/process-changelog/',
            'author' => 'Teppo Koivula',
            'version' => '1.14.6',
            'singular' => true,
            'autoload' => false,
            'icon' => 'code-fork',
            'permission' => 'changelog',
            'requires' => 'PHP>=7.1, ProcessWire>=3.0',
            'installs' => 'ProcessChangelogHooks',
        ];
    }

    /**
     * Default configuration for this module
     *
     * The point of putting this in it's own function is so that you don't have to specify
     * these defaults more than once.
     *
     * @return array
     */
    public static function getDefaultData() {
        return [
            'row_limit' => 25,
            'row_label' => 'name',
            'date_format' => 'Y-m-d H:i:s',
            'visible_filters' => [
                'operation',
                'username',
                'when',
                'date_range'
            ],
            'available_filters' => [
                'operation' => [
                    'label' => __("Operation"),
                    'options' => [
                        __("All operations"),
                    ],
                    'translate' => true,
                ],
                'template' => [
                    'label' => __("Template"),
                    'options' => [],
                    'translate' => false,
                ],
                'flags' => [
                    'label' => __("Flags"),
                    'options' => [
                        __("with any flags"),
                        __("with system flag") => 'System',
                        __("without system flag") => '!System'
                    ],
                    'translate' => false,
                ],
                'username' => [
                    'label' => __("Username"),
                    'options' => [],
                    'translate' => false,
                ],
                'role' => [
                    'label' => __("Role"),
                    'options' => [],
                    'translate' => false,
                ],
                'when' => [
                    'label' => __("When"),
                    'options' => [
                        __("whenever"),
                        __("within a day") => '1 DAY',
                        __("within a week") => '1 WEEK',
                        __("within a month") => '1 MONTH',
                        __("within a year") => '1 YEAR'
                    ],
                    'translate' => false,
                ],
                'date_range' => [
                    'label' => __("Date range"),
                    'options' => [],
                    'translate' => false,
                ],
            ],
            'rss_content_type' => 0,
        ];
    }

    /**
     * Name of the admin page related to this module
     *
     * @var string
     */
    const PAGE_NAME = 'changelog';

    /**
     * Name of the database table used by this module
     *
     * @var string
     */
    const TABLE_NAME = 'process_changelog';

    /**
     * Valid Content-Type headers for the RSS feed
     *
     * @var array
     */
    public static $rss_content_types = [
        0 => 'application/rss+xml',
        1 => 'application/xml',
        2 => 'text/xml',
    ];

    /**
     * Array of operations being logged
     *
     * @var array
     */
    protected $operations = [];

    /**
     * Array of template IDs, names and labels for caching purposes
     *
     * @var array
     */
    protected $template_cache = [];

    /**
     * Array of optional permissions
     *
     * - If "changelog-remove" exists, user has to have it in order to remove rows. If not,
     *   every user with access to this module can also remove rows.
     *
     * @var array
     */
    protected $optional_permissions = [];

    /**
     * Populate the default config data
     *
     * ProcessWire will automatically overwrite it with anything the user has specifically configured.
     * This is done in construct() rather than init() because ProcessWire populates config data after
     * construct(), but before init().
     */
    public function __construct() {
        // ProcessChangelogHooks module settings define which operations are
        // logged and the name of the database table they get stored into
        if ($this->modules->isInstalled("ProcessChangelogHooks")) {
            $config = $this->modules->getModuleConfigData("ProcessChangelogHooks");
            $defaults = $this->modules->get("ProcessChangelogHooks")->getDefaultData();
            $this->available_operations = $defaults['operations'];
            $this->operations = isset($config['operations']) ? array_combine($config['operations'], $config['operations']) : $defaults['operations'];
        }
        foreach (self::getDefaultData() as $key => $value) {
            if ($key == "available_filters") {
                // construct list of operations (done here so that we have
                // access to settings of ProcessChangelogHooks module.)
                $value['operation']['options'] = array_merge(
                    $value['operation']['options'],
                    $this->operations
                );
            }
            $this->$key = $value;
        }
        $this->optional_permissions = [
            'remove' => $this->permissions->get('changelog-remove'),
        ];
    }

    /**
     * Module configuration
     *
     * @param array $data
     * @return InputfieldWrapper
     */
    static public function getModuleConfigInputfields(array $data) {

        // this is a container for fields, basically like a fieldset
        $fields = new InputfieldWrapper();

        // since this is a static function, we can't use $this->modules, so get them from the global wire() function
        $modules = wire('modules');

        // merge local default settings and settings from hooks module (custom values overwrite defaults)
        $operations = [];
        if ($modules->isInstalled('ProcessChangelogHooks')) {
            $config = $modules->getModuleConfigData('ProcessChangelogHooks');
            if (isset($config['operations'])) {
                $operations = $config['operations'];
            } else {
                $operations = $modules->get('ProcessChangelogHooks')->getDefaultData()['operations'];
            }
        }
        $defaults = self::getDefaultData();
        $defaults['available_filters']['operation']['options'] = array_merge(
            $defaults['available_filters']['operation']['options'],
            $operations
        );
        $data = array_merge($defaults, $data);

        // visibility settings, grouped together by fieldset
        $display = $modules->get("InputfieldFieldset");
        $display->label = __("Display settings");
        $display->description = __("These settings control what (and how much) information gets displayed on the changelog page in admin.");
        $display->icon = "paint-brush";
        $fields->add($display);

        // date format used
        $field = $modules->get("InputfieldText");
        $field->name = "date_format";
        $field->label = __("Date Format");
        $field->notes = sprintf(__("See the %s function reference for more information on how to customize this format."), "[PHP date](http://www.php.net/manual/en/function.date.php)"); // Date format notes // %s will be replaced by a link to date section of PHP manual run-time
        $field->icon = "calendar";
        $field->value = $data['date_format'] ? $data['date_format'] : $defaults['date_format'];
        $display->add($field);

        // number of results visible at once
        $field = $modules->get("InputfieldSelect");
        $field->name = "row_limit";
        $field->label = __("Row Limit");
        $field->description = __("Number of rows visible at once");
        $field->icon = "scissors";
        $field->columnWidth = 50;
        $field->required = true;
        $field->addOptions([
            25 => '25',
            50 => '50',
            75 => '75',
            100 => '100',
        ]);
        $field->value = $data['row_limit'];
        $display->add($field);

        // field to use as row label
        $field = $modules->get("InputfieldSelect");
        $field->name = "row_label";
        $field->label = __("Row Label");
        $field->description = __("Which field should be used as row label?");
        $field->icon = "tag";
        $field->columnWidth = 50;
        $field->required = true;
        $field->addOptions([
            'name' => __("Page name"),
            'url' => __("Page URL"),
        ]);
        $field->value = $data['row_label'];
        $display->add($field);

        // visibility settings, grouped together by fieldset
        $visibility = $modules->get("InputfieldFieldset");
        $visibility->label = __("Visibility settings");
        $visibility->description = __("These settings control which filters and options are displayed in the changelog admin page.");
        $visibility->icon = "eye";
        $fields->add($visibility);

        // visible filters
        $field = $modules->get("InputfieldCheckboxes");
        $field->name = "visible_filters";
        $field->label = __("Visible filters");
        $field->notes = __("Unchecking all filters completely hides filters area.");
        $field->icon = "filter";
        foreach ($data['available_filters'] as $name => $filter) {
            $field->addOption($name, $filter['label']);
        }
        $field->value = $data['visible_filters'];
        $visibility->add($field);

        // values for hidden filters
        $hidden_filter_values = $modules->get("InputfieldFieldset");
        $hidden_filter_values->label = __("Values for hidden filters");
        $hidden_filter_values->description = __("These are used as the default values for hidden filters.");
        $hidden_filter_values->notes = __("Filters not listed here are ignored when hidden.");
        $hidden_filter_values->icon = "eye-slash";
        foreach ($data["available_filters"] as $name => $filter) {
            if (!$filter["options"]) continue;
            $field = $modules->get("InputfieldSelect");
            $field->name = "default_for_" . $name;
            $field->label = $filter["label"];
            $field->icon = "cog";
            foreach ($filter["options"] as $key => $option) {
                $value = $key ? $option : "";
                $text = !is_numeric($key) ? $key : $option;
                if ($filter["translate"]) {
                    if ($text == "deleted" && $name == "operation") {
                        // "deleted" is used in multiple contexts
                        $text = _x($text, $name);
                    } else {
                        $text = __($text);
                    }
                }
                $field->addOption($value, $text);
            }
            if (isset($data["default_for_" . $name])) {
                $field->value = $data["default_for_" . $name];
            }
            $hidden_filter_values->add($field);
        }
        $visibility->add($hidden_filter_values);

        // RSS settings
        $rss = $modules->get("InputfieldFieldset");
        $rss->label = __("RSS settings");
        $rss->description = __("These are the settings applied when the module renders RSS feeds.");
        $rss->icon = "rss";
        $fields->add($rss);

        // RSS Content-Type header
        $field = $modules->get("InputfieldSelect");
        $field->name = "rss_content_type";
        $field->label = __("RSS content type");
        $field->description = __("The value of the content-type header that gets sent with an RSS feed.");
        $field->icon = "code";
        $field->addOptions(self::$rss_content_types);
        $field->value = $data['rss_content_type'];
        $rss->add($field);

        return $fields;
    }

    /**
     * Initialization function called before any execute functions
     */
    public function init() {

        parent::init();

        // if more than one of operation, template, and flags exist in visible filters, add "all operations on"
        // to available options for the operation filter
        if (count(array_intersect(['operation', 'template', 'flags'], $this->visible_filters)) > 1) {
            $available_filters = $this->available_filters;
            $available_filters['operation']['options'] = array_merge(
                [
                    $this->_("All operations on"),
                ],
                $this->operations
            );
            $this->available_filters = $available_filters;
        }

        // should date formatting occur?
        $defaults = self::getDefaultData();
        if ($this->date_format == $defaults['date_format']) {
            unset($this->date_format);
        }

        // take values for hidden filters into account
        $hidden_filters = array_diff(array_keys($this->available_filters), $this->visible_filters);
        foreach ($hidden_filters as $filter) {
            $this->input->get->$filter = $this->get("default_for_$filter");
        }
    }

    /**
     * Executed when a page with this Process assigned is accessed
     *
     * @return string
     */
    public function ___execute() {

        // make sure that we have a newish version of Font-Awesome loaded
        if (version_compare($this->config->version, '3.0.18', '<')) {
            $this->config->styles->add('//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css');
        }

        // render filters (this has to be done here because certain filter
        // choices may affect choices available when building SQL queries)
        $filters = $this->renderFilters();

        // setup admin data table
        /** @var MarkupAdminDataTable */
        $table = $this->modules->get("MarkupAdminDataTable");
        $table->setEncodeEntities(false);
        $table->setClass('log');
        $table->headerRow([
            $this->_('When'),
            $this->_('Who'),
            $this->_('What'),
            $this->_('Remove'),
            $this->_('More')
        ]);

        // fetch rows from database and add them to our data table
        $query = $this->buildQuery();
        $stmt = $this->database->prepare($query['query']);
        $stmt->execute();
        while ($row = $stmt->fetch(\PDO::FETCH_ASSOC)) {
            $table->row($this->parseTableRow($row));
        }

        // if less than two matches were found, disable table sorting
        if ($query['total'] < 2) $table->setSortable(false);

        // pager markup
        $pager = "";
        if ($query['limit'] && $query['total'] > $query['limit']) {
            $pager_links = 20;
            $pager_page = (int) $query['start']/$query['limit']+1;
            $pager_pages = ceil($query['total']/$query['limit']);
            $pager = $this->renderPager($pager_links, $pager_page, $pager_pages);
        }

        // UI translations
        $this->config->js('log', [
            'i18n' => [
                'more' => $this->_("more"),
                'less' => $this->_("less"),
                'areYouSure' => $this->_("Are you sure?"),
                'removeFailed' => $this->_("Sorry, remove failed"),
            ],
        ]);

        // basic information about found rows
        $info = "<div id='info'><h2>";
        $info .= sprintf(_n("One matching row found.", "%d matching rows found.", $query['total']), $query['total']);
        $info .= "</h2></div>";

        // feed links
        $feeds = "<ul id='feeds'>";
        $feeds .= "<li><a href='./rss/' target='_blank'>" . $this->_('RSS') . "</a></li>";
        if ($this->modules->isInstalled('ProcessChangelogRSS')) {
            /** @var ProcessChangelogRSS */
            $changelogRSS = $this->modules->get('ProcessChangelogRSS');
            if ($changelogRSS->show_feed_link) {
                $feed_url = $changelogRSS->getRSSFeedURL();
                if ($feed_url) {
                    $feeds .= "<li><a href='{$feed_url}' target='_blank'>" . $this->_('Public RSS') . "</a></li>";
                    unset($feed_url);
                }
            }
        }
        $feeds .= "</ul>";

        // return admin data table markup and pager
        return $filters . $info . $table->render() . $pager . $feeds;
    }

    /**
     * Executed when a page with this Process assigned is accessed with /JSON/
     */
    public function ___executeJSON() {

        // fetch rows from database
        $data = [];
        $query = $this->buildQuery();
        $stmt = $this->database->prepare($query['query']);
        $stmt->execute();
        while ($row = $stmt->fetch(\PDO::FETCH_ASSOC)) $data[] = $row;

        // send header and output JSON
        header('Content-type: application/json');
        exit(json_encode($data));
    }

    /**
     * Executed when a page with this Process assigned is accessed with /RSS/
     */
    public function ___executeRSS() {

        // create rss element
        $rss = new \SimpleXMLElement('<rss/>');
        $rss->addAttribute('version', '2.0');

        // create channel element
        $channel = $rss->addChild('channel');
        $channel->addChild('title', $this->_('Changelog'));
        $channel->addChild('link', $this->input->httpUrl . ($_GET ? '?' . htmlentities($this->input->queryString) : ''));
        $channel->addChild('description', $this->_('An automatically generated changelog for this site.'));

        // fetch rows from database
        $query = $this->buildQuery();
        $stmt = $this->database->prepare($query['query']);
        $stmt->execute();
        $link_base_url = 'http' . ($this->config->https ? 's' : '') . '://' . $this->config->httpHost . $this->config->urls->admin . 'page/edit/?id=';
        $guid_base_url = null;
        $process_page = $this->pages->get("template=admin, process=" . $this->modules->getModuleID($this) . ", name=" . self::PAGE_NAME);
        if ($process_page->id) {
            $guid_base_url = 'http' . ($this->config->https ? 's' : '') . '://' . $this->config->httpHost . $process_page->url . '?id=';
        }
        while ($row = $stmt->fetch(\PDO::FETCH_ASSOC)) {
            $item = $channel->addChild('item');
            $item->addChild('title', $this->parseString($row));
            if (!empty($row['data'])) {
                $details = json_decode($row['data'], true);
                $item->description = $this->sanitizer->unentities($this->renderDetails($row['operation'], $details));
            } else {
                $item->addChild('description', $this->_("No data available."));
            }
            $item->addChild('link', $link_base_url . (int) $row['pages_id']);
            if ($guid_base_url) {
                $item->addChild('guid', $guid_base_url . (int) $row['id']);
            }
            $item->addChild('pubDate', date(\DATE_RSS, strtotime($row['timestamp'])));
        }

        // send header and output RSS
        if (((int) $this->rss_content_type != $this->rss_content_type) || !isset(self::$rss_content_types[$this->rss_content_type])) {
            $this->rss_content_type = 0;
        };
        header('Content-type: ' . self::$rss_content_types[$this->rss_content_type] . '; charset=UTF-8');
        exit($rss->asXML());
    }

    /**
     * Build SQL query for fetching changelog data from custom database table
     *
     * @param array $group_by Fields to group results by, such as "id"
     * @return array Array with SQL query ('query'), total row count ('total'), start ('start') and limit ('limit')
     *
     * @throws WireException if template data can't be found
     * @throws WireException if template flag is not recognized
     */
    private function buildQuery(array $group_by = []): array {

        // $joins, $where and $group_by arrays are used to construct where clause, joins, and group by statement later.
        // $where contains rules like "key = '$value'" and group by contains field names, while $joins contains actual
        // joins, such as "LEFT JOIN table ON table.id = $id".
        $joins = [];
        $where = [];
        $group_by = [];

        // Allowed keys (GET params used to build queries) are defined here to
        // make sure we're not letting any weird queries get past us.
        $allowed_keys = [
            "id",
            "template",
            "field",
            "flags",
            "user_id",
            "username",
            "role",
            "pages_id",
            "operation",
            "when",
            "date_from",
            "date_until",
        ];

        // Possible values for 'when' filter
        $allowed_intervals = array_values(
            $this->available_filters['when']['options']
        );

        foreach ($this->input->get as $key => $value) {
            if (in_array($key, $allowed_keys) && $value != "") {
                $operator = "=";
                $value = $this->database->escapeStr($value);
                if (strpos($value, "!") === 0) {
                    $operator = "!=";
                    $value = substr($value, 1);
                }
                switch ($key) {
                    case "data":
                        $where[] = "{$key} LIKE '%{$value}%'";
                        break;
                    case "when":
                        if (!isset($where['date_from']) && !isset($where['date_until']) && in_array($value, $allowed_intervals)) {
                            $where[$key] = "DATE_SUB(CURDATE(), INTERVAL {$value}) <= timestamp";
                        }
                        break;
                    case "date_from":
                    case "date_until":
                        if (!isset($where['when'])) {
                            $value = date("Y-m-d", strtotime($value));
                            $operator = "<=";
                            $time = "23:59";
                            if ($key == "date_from") {
                                $operator = ">=";
                                $time = "00:00";
                            }
                            $where[$key] = "timestamp {$operator} '{$value} {$time}'";
                        }
                        break;
                    case "template":
                        $join = "LEFT OUTER JOIN pages ON pages.id = " . self::TABLE_NAME . ".pages_id";
                        if (!in_array($join, $joins)) $joins[] = $join;
                        $template = $this->getCacheTemplate($value);
                        if ($template) {
                            $where[] = "(pages.templates_id {$operator} {$template['id']}"
                                     . " OR " . self::TABLE_NAME . ".templates_id {$operator} {$template['id']})";
                        } else {
                            throw new WireException(sprintf($this->_("Template not found: %s"), $this->sanitizer->pageName($value)));
                        }
                        break;
                    case "role":
                        if ($value === "guest") {
                            $role = $this->roles->get('guest');
                            if ($operator === '!=') {
                                $joins[] = "JOIN field_roles field_roles_not ON " . self::TABLE_NAME . ".user_id = field_roles_not.pages_id AND field_roles_not.data != " . (int) $role->id;
                            } else {
                                $joins[] = "LEFT JOIN field_roles field_roles_not ON " . self::TABLE_NAME . ".user_id = field_roles_not.pages_id AND field_roles_not.data != " . (int) $role->id;
                                $where[] = "field_roles_not.pages_id IS NULL";
                            }
                            $group_by[] = self::TABLE_NAME . ".id";
                        } else if ($this->sanitizer->pageName($value) == $value) {
                            $role = $this->roles->get('name=' . $value);
                            if ($role->id) {
                                $joins[] = ($operator === '!=' ? 'LEFT ' : '') . "JOIN field_roles ON field_roles.pages_id = " . self::TABLE_NAME . ".user_id AND field_roles.data = " . (int) $role->id;
                                if ($operator === '!=') {
                                    $where[] = "field_roles.pages_id IS NULL";
                                }
                            }
                        }
                        break;
                    case "field":
                        // note: this option is intentionally left out of the GUI in part due to bad performance with
                        // larger amounts of data
                        $value = preg_quote($value);
                        $where[] = self::TABLE_NAME . ".data REGEXP '\"Fields edited\"\:\"(?:.*? |){$value}(?:,|\")'";
                        break;
                    case "flags":
                        $join = "LEFT OUTER JOIN pages ON pages.id = " . self::TABLE_NAME . ".pages_id";
                        if (!in_array($join, $joins)) $joins[] = $join;
                        $joins[] = "JOIN templates ON templates.id IN(pages.templates_id, " . self::TABLE_NAME . ".templates_id)";
                        if ($flag = constant("Template::flag$value") ?: constant("\ProcessWire\Template::flag$value")) {
                            // since this is a bitwise operation, we need to modify our operator logic... a bit :)
                            $negation = strpos($operator, "!") === 0;
                            $where[] = "templates.flags & " . (int) $flag;
                            if ($negation) $where[count($where)-1] = "NOT(" . $where[count($where)-1] . ")";
                        } else {
                            throw new WireException(sprintf($this->_("Flag not supported: %s"), $value));
                        }
                        break;
                    case "operation":
                        if (!in_array($value, array_flip($this->operations))) {
                            unset($this->input->get->$key);
                            break;
                        }
                    default:
                        $where[] = self::TABLE_NAME . ".{$key} {$operator} " . (substr($key, -3) === '_id' ? (int) $value : "'{$value}'");
                }
            }
        }

        // make sure that only operations being currently logged are visible,
        // even after selecting "all operations"
        if (!$this->input->get->operation && $this->operations != $this->available_operations) {
            $value = $this->database->escapeStr(implode(",", $this->operations));
            $where[] = "operation IN('" . str_replace(",", "','", $value) . "')";
        }

        // put together WHERE clause, required JOINs and GROUP BY
        $where = $where ? "WHERE " . implode(" AND ", $where) : "";
        $joins = $joins ? " " . implode(" ", $joins) : "";
        $group_by = $group_by ? "GROUP BY " . implode(", ", $group_by) : "";

        // total count of rows in database table
        $count = $group_by ? "DISTINCT " . substr($group_by, 9) : "*";
        $sql = "SELECT COUNT({$count}) FROM " . self::TABLE_NAME . " {$joins} {$where}";
        $stmt = $this->database->prepare($sql);
        $stmt->execute();
        $row = $stmt->fetch(\PDO::FETCH_NUM);
        $total = reset($row);

        // put together LIMIT
        $start = 0;
        $limit = isset($this->input->get->limit) ? (int) $this->input->get->limit : $this->row_limit;
        if ($limit && $total > $limit) {
            if ($this->input->get->page) $start = ($this->input->get->page-1)*$limit;
            if ($start > $total) $start = $total-$limit;
        }

        // put together ORDER BY
        $sort = "";
        $order_by = "ORDER BY ";
        if ($this->input->get->sort) {
            $sort_fields = [
                'id',
                'user_id',
                'username',
                'pages_id',
                'templates_id',
                'operation',
                'timestamp',
            ];
            if (in_array(ltrim($this->input->get->sort, '-'), $sort_fields)) {
                $sort = $this->input->get->sort;
                $sort_order = strpos($sort, "-") === 0 ? "DESC" : "ASC";
                if ($sort_order == "DESC") $sort = substr($sort, 1);
                if ($sort == "timestamp") $sort = "id";
                $sort = $this->database->escapeStr($sort);
                $order_by .= "{$sort} {$sort_order}";
                if ($sort != "id") $order_by .= ", ";
            }
        }
        if ($sort != "id") $order_by .= "id DESC";

        // stick pieces together to construct final SQL query
        $query = "SELECT " . self::TABLE_NAME . ".* FROM " . self::TABLE_NAME . " {$joins} {$where} {$group_by} {$order_by}";
        if ($limit) $query .= " LIMIT {$start}, {$limit}";

        // return SQL query along with some additional data
        return [
            'query' => $query,
            'total' => $total,
            'start' => $start,
            'limit' => $limit,
        ];

    }

    /**
     * Parse MarkupAdminDataTable row from a row fetched from database
     *
     * @param array $row
     * @return array
     */
    private function parseTableRow(array $row): array {

        // container
        $data = [];

        // escape values (just a precaution really)
        foreach ($row as $key => $value) {
            if ($key != "data") $row[$key] = htmlentities($value);
        }

        // timestamp (raw timestamp is hidden and only included to allow proper sorting with JavaScript)
        $time = strtotime($row['timestamp']);
        $date = $this->date_format ? date($this->date_format, $time) : $row['timestamp'];
        $date = str_replace('-', 'â€‘', $date);
        $data[] = "<span hidden>" . str_replace(['-', ':', ' '], '', $row['timestamp']) . "</span>"
            . "<time datetime='" . date('c', $time) . "'>{$date}</time>";

        // username
        $selected = $this->input->get->username == $row['username'] ? ' selected' : '';
        $query_string = $this->parseQueryString([
            'username' => $selected ? null : $row['username'],
        ]);
        $filter = " <a class='ajax action{$selected}' href='?{$query_string}'>"
            . "<i class='fa fa-filter' aria-label='" . sprintf($this->_('Filter by username: %s'), $row['username']) . "'></i>"
            . "</a>";
        if ($row['username'] == 'guest') {
            // guest user, no need to show an edit link
            $data[] = "<span class='user guest visual-label'>"
                . "<i class='icon' aria-hidden='true'></i>"
                . $this->_('guest')
                . "</span>"
                . $filter;
        } else {
            // check if user still exists and if yes, provide an edit link
            $user = $this->users->get((int) $row['user_id']);
            if ($user->id) {
                $data[] = "<a class='user' href='{$this->config->urls->admin}access/users/edit/?id={$user->id}'>"
                    . "<i class='icon' aria-hidden='true'></i>"
                    . "<span class='visually-hidden'>" . sprintf($this->_('Edit user: %s'), $user->name). "</span>"
                    . "<span class='visual-label' aria-hidden='true'>{$user->name}</span>"
                    . "</a>"
                    . $filter;
            } else {
                $label = $this->_("deleted user");
                $data[] = "<span class='user deleted visual-label' title='{$label}' aria-label='{$label}: {$row['username']}'>"
                    . "<i class='icon' aria-hidden='true'></i>"
                    . $row['username']
                    . "</span>"
                    . $filter;
            }
        }

        // translatable operations
        // $this->_('added')
        // $this->_('moved')
        // $this->_('edited')
        // $this->_('trashed')
        // $this->_('renamed')
        // $this->_x('deleted', 'operation')
        // $this->_('restored')
        // $this->_('published')
        // $this->_('unpublished')

        // variables we're going to need later
        $target = "";
        $template = "";
        $operation = $row['operation'];
        $page = $this->pages->get($row['pages_id']);
        $details = json_decode($row['data'], true);
        $key = $this->row_label == 'url' ? 'page URL' : 'page name';

        // start putting together human-readable version of what happened
        switch ($operation) {
            case 'renamed':
                $previous_value = isset($details["Previous $key"]) ? $details["Previous $key"] : '(' . $this->_('empty') . ')';
                $target .= "<span class='page'>" . $previous_value . "</span>"
                        . " <strong>" . $this->_("as") . "</strong>" // as // In context of a rename operation ("renamed old-page-name as new-page-name")
                        . " <span class='page'>" . $details[ucfirst($key)] . "</span>";
                break;
            case 'trashed':
                $target .= "<span class='page'>" . $details["Previous $key"] . " <i class='fa fa-arrow-right'></i> " . $details[ucfirst($key)] . "</span>";
                break;
            default:
                $target .= "<span class='page'>" . $details[ucfirst($key)] . "</span>";
        }

        if ($page->id) {
            $template = $page->template;
            if ($page->editable()) {
                // append edit link to target
                $href = "{$this->config->urls->admin}page/edit/?id={$page->id}";
                $target .= " &nbsp; <a class='action edit-page' href='{$href}'>"
                    . "<span class='visual-label' aria-hidden='true'>" . $this->_('edit page') . "</span>"
                    . "<span class='visually-hidden'>" . sprintf($this->_('Edit page: %s'), $page->name) . "</span>"
                    . "</a>";
            }
            if ($page->viewable()) {
                // append view link to target
                $href = $page->url;
                $target .= " &nbsp; <a class='action edit-page' href='{$href}'>"
                    . "<span class='visual-label' aria-hidden='true'>" . $this->_('view page') . "</span>"
                    . "<span class='visually-hidden'>" . sprintf($this->_('View page: %s'), $page->name) . "</span>"
                    . "</a>";
            }
        } else if ($row['templates_id']) {
            $template = $this->templates->get((int) $row["templates_id"]);
        }

        if ($template) {
            $template_icons = "";
            if ($template->flags & Template::flagSystem) {
                $template_icons .= " <i class='fa fa-gear' title='(" . $this->_("System template") . ")'></i>";
            }
            $template_label = $template->label ? $template->label : $template;
            if (in_array('template', $this->visible_filters)) {
                $selected = $this->input->get->template == $template->name ? ' selected' : '';
                $query_string = $this->parseQueryString([
                    'template' => $selected ? '' : $template->name,
                ]);
                $template = "<a class='ajax tag template{$selected}' href='?{$query_string}'><i class='icon' aria-hidden='true'></i>{$template_label}{$template_icons}</a> ";
            } else {
                $template = "<strong class='template'>{$template_label}{$template_icons}</strong> ";
            }
        } else {
            // template is unknown or has been deleted
            $template = "<strong class='deleted'>" . $this->_('deleted') . "</strong>";
        }

        // "deleted" is only phrase used in multiple contexts
        if ($operation != 'deleted') $operation_i18n = $this->_($operation);
        else $operation_i18n = _x($operation, 'operation');

        $selected = $this->input->get->operation == $operation ? ' selected' : '';
        $query_string = $this->parseQueryString([
            'operation' => $selected ? '' : $operation,
        ]);
        $data[] = "<a class='ajax tag{$selected}' href='?{$query_string}'>"
            . "<i class='icon' aria-hidden='true'></i>"
            . "<span class='visually-hidden'>" . sprintf($this->_('Filter by operation: %s'), $operation_i18n) . "</span>"
            . "<span class='visual-label' aria-hidden='true'>{$operation_i18n}</span>"
            . "</a> {$template} {$target}";

        // link for removing individual row
        if (!$this->optional_permissions['remove']->id || $this->user->hasPermission($this->optional_permissions['remove'])) {
            $data[] = "<a href='./delete/?id={$row['id']}' class='action remove-row'>"
                . "<span class='visual-label' aria-hidden='true'>" . $this->_("remove?") . "</span>"
                . "<span class='visually-hidden'>" . $this->_("remove current row") . "</span>"
                . "</a>";
        } else {
            $data[] = "";
        }

        // more details about page in question
        $data[] = $details ? $this->renderDetails($operation, $details) : $this->_("No data available.");

        return $data;
    }

    /**
     * Parse query string based on GET variables and provided additional arguments
     *
     * @param array $args Additional arguments
     * @return string
     */
    private function parseQueryString(array $args = []) {
        return htmlentities(
            http_build_query(
                array_merge(
                    $this->input->get->getArray(),
                    $args
                )
            )
        );
    }

    /**
     * Parse string from a row fetched from database
     *
     * @param array $row
     * @return string
     */
    private function parseString(array $row) {

        $out = [];

        // escape values (just a precaution really)
        foreach ($row as $key => $value) {
            if ($key != "data") $row[$key] = htmlentities($value);
        }

        // user
        $user = $this->users->get($row['user_id']);
        $out[] = $user->id ? $user->name : $row['username'] . " (" . $this->_("deleted") . ")";

        // operation
        $operation_i18n = $this->_($row['operation']);
        if ($row['operation'] == "deleted") $operation_i18n = _x($row['operation'], 'operation');
        $out[] = $operation_i18n;

        // template
        $template = "";
        $page = $this->pages->get($row['pages_id']);
        if ($page->id) {
            $template = $page->template;
        } else if ($row["templates_id"] && $this->templates->get($row["templates_id"])) {
            $template = $this->templates->get($row["templates_id"]);
        }
        $out[] = $template ? ($template->label ?: $template) : $this->_("Page");

        // target
        $details = json_decode($row['data'], true);
        $key = $this->row_label == 'url' ? 'page URL' : 'page name';
        switch ($row['operation']) {
            case 'renamed':
                $out[] = $details["Previous $key"] . " " . $this->_("as") . " " . $details[ucfirst($key)];
                break;
            case 'trashed':
                $out[] = $details["Previous $key"] . " (" . $details[ucfirst($key)] . ")";
                break;
            default:
                $out[] = $details[ucfirst($key)];
        }

        return implode(" ", $out);
    }

    /**
     * Render markup for pager
     *
     * @param int $links Number of pager links visible at once
     * @param int $page Identifies currently active pager item
     * @param int $pages Number of total pager items available
     * @return string
     */
    private function renderPager(int $links, int $page, int $pages): string {

        if ($pages < 2) return '';

        // convert GET params to string
        $get = "";
        foreach ($this->input->get as $key => $value) {
            if ($key != "page" && $value != "" && !is_array($value)) {
                $get .= "&amp;" . urlencode($key) . "=" . urlencode($value);
            }
        }

        // calculate start and end points
        $start = 1;
        $end = $pages;
        if ($end > $links) {
            $start = (int) $page - $links / 2;
            if ($start < 1) $start = 1;
            $end = $start + ($links - 1);
            if ($end > $pages) $end = $pages;
            if ($end - $page < (int) $links / 2 - 1) {
                $start -= ((int) $links / 2) - ($end - $page);
                if ($start < 1) $start = 1;
            }
        }

        // generate markup
        $out = "";
        $pager_config = $this->config->MarkupPagerNav ?: [
            'currentItemClass' => 'uk-active MarkupPagerNavOn',
            'separatorItemLabel' => '<span>&hellip;</span>',
            'separatorItemClass' => 'uk-disabled MarkupPagerNavSeparator',
            'listMarkup' => "<ul class='uk-pagination MarkupPagerNav'>{out}</ul>",
        ];
        if ($start > 1) {
            $out .= "<li><a href='./?page=1{$get}'><span>1</span></a></li>";
            if ($start > 2) {
                $out .= "<li class='{$pager_config['separatorItemClass']}'>{$pager_config['separatorItemLabel']}</li>";
            }
        }
        for ($i = $start; $i <= $pages; ++$i) {
            $here = $page == $i ? " class='{$pager_config['currentItemClass']}'" : "";
            $out .= "<li{$here}><a href='./?page={$i}{$get}'><span>{$i}</span></a></li>";
            if ($pages > $links && $i == $end && $i < $pages) {
                if ($pages - $i > 1) {
                    $out .= "<li class='{$pager_config['separatorItemClass']}'>{$pager_config['separatorItemLabel']}</li>";
                }
                $i = $pages-1;
                if ($i < $end) $i = $end + 1;
            }
        }
        $out = str_replace(
            '{out}',
            $out,
            $pager_config['listMarkup']
        );

        return "<div class='MarkupPagerNavCustom'>{$out}</div>";
    }

    /**
     * Render human readable view of row details
     *
     * @param string|null $operation
     * @param array $details
     * @return string
     */
    private function renderDetails(?string $operation = null, array $details = []): string {

        // action details are required
        if (empty($details)) return '';

        // init vars
        $markup = "";
        $class = $operation ? " icon-{$operation}" : "";

        // translatable phrases
        // $this->_('Previous page name')
        // $this->_('Current page name')
        // $this->_('Page name')
        // $this->_('Page title')
        // $this->_('Parent page')
        // $this->_('Previous parent page')
        // $this->_('Page URL')
        // $this->_('Previous URL')
        // $this->_('Current URL')
        // $this->_('Fields edited')
        // $this->_('Caller')

        foreach ($details as $key => $value) {
            // escape key and value
            $key = htmlentities($key);
            $value = htmlentities($value);
            // generate markup
            $markup .= "<tr><th>" . $this->_($key) . "</th><td>{$value}</td></tr>";
        }

        return "<div class='details-table{$class}'>"
            . "<i class='js-icon' aria-hidden='true'></i>"
            . "<table class='details' tabindex='-1'>{$markup}</table>"
            . "</div>";
    }

    /**
     * Executed when requesting removal of an individual row
     *
     * @return int|false
     *
     * @throws WirePermissionException if changelog-remove permission exists but the current user doesn't have it
     */
    public function ___executeDelete() {
        if (!$this->optional_permissions['remove']->id || $this->user->hasPermission($this->optional_permissions['remove'])) {
            if ((int) $this->input->get->id != $this->input->get->id) {
                return false;
            }
            $id = (int) $this->input->get->id;
            $sql = "DELETE FROM " . self::TABLE_NAME . " WHERE id=:id LIMIT 1";
            $stmt = $this->database->prepare($sql);
            $stmt->bindValue(':id', $id, \PDO::PARAM_INT);
            $stmt->execute();
            return 1;
        }
        throw new WirePermissionException($this->_("You do not have the permission required by this action."));
    }

    /**
     * Render markup for result filter UI
     *
     * @return string
     */
    private function renderFilters(): string {

        $markup = "";

        // operations
        $markup .= $this->renderSelect(
            'operation',
            $this->_('Operation'),
            array_flip($this->available_filters['operation']['options'])
        );

        // templates
        if (in_array('template', $this->visible_filters)) {
            $options = [];
            $join_flags = "";
            if ($this->input->get->flags) {
                $flag = str_replace("_", "", $this->sanitizer->name($this->input->get->flags));
                if (constant("Template::flag{$flag}")) {
                    $and_on = "templates.flags & " . constant("Template::flag{$flag}");
                    if (strpos($this->input->get->flags, "!") === 0) $and_on = "NOT({$and_on})";
                    $join_flags .= "JOIN templates "
                                 . "ON templates.id = " . self::TABLE_NAME . ".templates_id "
                                 . "AND {$and_on}";
                }
            }
            $sql = "SELECT DISTINCT " . self::TABLE_NAME . ".templates_id FROM " . self::TABLE_NAME . " {$join_flags}";
            $stmt = $this->database->prepare($sql);
            $stmt->execute();
            $rowCount = $stmt->rowCount();
            if (!$rowCount || $rowCount > 1) {
                $options[] = $this->_("pages");
            }
            while ($row = $stmt->fetch(\PDO::FETCH_ASSOC)) {
                $template = $this->getCacheTemplate(null, (int) $row['templates_id']);
                $key = sprintf($this->_("%s pages"), $template['label']); // %s pages // %s will be replaced run-time by template
                $options[$key] = $template['name'];
            }
            $markup .= $this->renderSelect('template', $this->_('Template'), $options);
        }

        // flags
        if (in_array('flags', $this->visible_filters)) {
            $options = $this->available_filters['flags']['options'];
            if (!in_array('template', $this->visible_filters)) {
                foreach ($options as $option => $value) {
                    $new_option = $option ? $this->_("pages ") . $option : 0; // pages // In context of flags ("pages with system flags" etc.)
                    if ($new_option) unset($options[$option]);
                    else $value = $this->_("pages ") . $value;
                    $options[$new_option] = $value;
                }
            }
            if ($this->input->get->template) {
                // if template is set, some flag options may not be applicable
                $template = $this->sanitizer->pageName($this->input->get->template);
                $template_flags = $this->templates->get($template)->flags;
                foreach ($options as $key => $value) {
                    // note: sanitizer->name converts illegal characters (including
                    // negation operator) to underscores, which are then removed to
                    // catch possible flag names
                    $flag = str_replace("_", "", $this->sanitizer->name($value));
                    if (defined("Template::flag{$flag}")) {
                        $negation = strpos($value, "!") === 0;
                        $has_flag = $template_flags & constant("Template::flag{$flag}");
                        if ($negation && $has_flag || !$negation && !$has_flag) {
                            if ($this->input->get->flags == $options[$key]) {
                                // flag being removed from available options is
                                // used as search criteria; unset GET param too
                                unset($this->input->get->flags);
                            }
                            unset($options[$key]);
                        }
                    }
                }
                // unset "with any flags" if flags matched
                if (count($options) > 1) unset($options[0]);
            }
            $markup .= $this->renderSelect('flags', $this->_('Flags'), $options);
        }

        // role
        if (in_array('role', $this->visible_filters)) {
            $options = [''];
            foreach ($this->roles as $role) {
                $options[$role->id] = $role->name;
            }
            if (in_array('username', $this->visible_filters)) {
                $markup .= "<span class='filter-label' aria-hidden='true'>"
                    . (in_array("operation", $this->visible_filters) ? $this->_('by')
                        : $this->_('modified by'))
                    . "</span>";
            } else {
                $markup .= "<span class='filter-label' aria-hidden='true'>"
                . (in_array("operation", $this->visible_filters) ? $this->_('by user with')
                    : $this->_('modified by user with'))
                . "</span>";
            }
            $markup .= $this->renderSelect('role', $this->_('Role'), $options);
            if (!in_array('username', $this->visible_filters)) {
                $markup .= "<span class='filter-label' aria-hidden='true'>"
                    . $this->_('role')
                    . "</span>";
            }
        }

        // username
        if (in_array('username', $this->visible_filters)) {
            $options = [''];
            $where = [];
            $joins = [];
            if (in_array('role', $this->visible_filters) && $this->input->get->role) {
                $operator = "=";
                $role_name = $this->input->get->role;
                if (strpos($role_name, "!") === 0) {
                    $operator = "!=";
                    $role_name = substr($role_name, 1);
                }
                if ($role_name === 'guest') {
                    $role = $this->roles->get('guest');
                    if ($operator === '!=') {
                        $joins[] = "JOIN field_roles field_roles_not ON " . self::TABLE_NAME . ".user_id = field_roles_not.pages_id AND field_roles_not.data != " . (int) $role->id;
                    } else {
                        $joins[] = "LEFT JOIN field_roles field_roles_not ON " . self::TABLE_NAME . ".user_id = field_roles_not.pages_id AND field_roles_not.data != " . (int) $role->id;
                        $where[] = "field_roles_not.pages_id IS NULL";
                    }
                    if ($this->input->get->username && $this->sanitizer->pageName($this->input->get->username) == $this->input->get->username) {
                        $selected_user = $this->users->get('name=' . $this->input->get->username);
                        if ($selected_user->id && !$selected_user->hasRole('guest') || $selected_user->id && $selected_user->roles->count() > 1) {
                            $this->input->get->username = null;
                        }
                    }
                } else if ($this->sanitizer->pageName($role_name) == $role_name) {
                    $role = $this->roles->get('name=' . $role_name);
                    if ($role->id) {
                        $joins[] = ($operator === '!=' ? 'LEFT ' : '') . "JOIN field_roles ON field_roles.pages_id = " . self::TABLE_NAME . ".user_id AND field_roles.data = " . (int) $role->id;
                        if ($operator === '!=') {
                            $where[] = "field_roles.pages_id IS NULL";
                        }
                        if ($this->input->get->username && $this->sanitizer->pageName($this->input->get->username) == $this->input->get->username) {
                            $selected_user = $this->users->get('name=' . $this->input->get->username);
                            if ($selected_user->id && !$selected_user->hasRole($role)) {
                                $this->input->get->username = null;
                            }
                        }
                    }
                }
            }
            if (in_array($this->input->get->operation, $this->operations)) {
                $where[] = "operation = '{$this->input->get->operation}'";
            } else if ($this->operations != $this->available_operations) {
                $where[] = "operation IN('" . implode("','", $this->operations) . "')";
            }
            $where = $where ? "WHERE " . implode(" AND ", $where) : "";
            $joins = $joins ? implode(" ", $joins) : "";
            $sql = "SELECT DISTINCT username
                    FROM " . self::TABLE_NAME . "
                    {$joins}
                    {$where}
                    ORDER BY username DESC";
            $stmt = $this->database->prepare($sql);
            $stmt->execute();
            $rowCount = $stmt->rowCount();
            if (in_array('role', $this->visible_filters)) {
                $markup .= "<span class='filter-label' aria-hidden='true'>"
                . $this->_('user')
                . "</span>";
            } else {
                $markup .= "<span class='filter-label' aria-hidden='true'>"
                . (in_array("operation", $this->visible_filters) ? $this->_('by')
                    : $this->_('modified by'))
                . "</span>";
            }
            while ($row = $stmt->fetch(\PDO::FETCH_ASSOC)) {
                $key = $row['username'] == "guest" ? $this->_("guest") : $row['username'];
                $options[$key] = $row['username'];
            }
            $markup .= $this->renderSelect('username', $this->_('Username'), $options);
        }

        // when
        if (in_array('when', $this->visible_filters) || in_array('date_range', $this->visible_filters)) {
            $options = array();
            if (in_array('when', $this->visible_filters)) {
                $options = $this->available_filters['when']['options'];
                if (in_array('date_range', $this->visible_filters)) {
                    $options[$this->_("between")] = "between";
                }
                $markup .= $this->renderSelect('when', $this->_('When'), $options);
            }

            // date range
            if (in_array('date_range', $this->visible_filters)) {
                $disabled_title = $this->_("Not relevant in this context");
                $date_from = $this->input->get->date_from ? date('d.m.Y', strtotime($this->input->get->date_from)) : '';
                $date_until = $this->input->get->date_until ? date('d.m.Y', strtotime($this->input->get->date_until)) : '';
                $markup .= "<div class='filter no-icon'>"
                         . "<input type='text'"
                         . " value='{$date_from}'"
                         . " size='10'"
                         . " data-maxdate='+0D'"
                         . " data-dateformat='dd.mm.yy'"
                         . " name='date_from'"
                         . " data-disabled-title='{$disabled_title}'"
                         . " class='log-datepicker'"
                         . " />"
                         . "</div>"
                         . "<div class='filter-spacer'>...</div>"
                         . "<div class='filter no-icon'>"
                         . "<input type='text'"
                         . " value='{$date_until}'"
                         . " size='10'"
                         . " data-maxdate='+0D'"
                         . " data-dateformat='dd.mm.yy'"
                         . " name='date_until'"
                         . " class='log-datepicker'"
                         . " />"
                         . "</div>";
            }
        }

        // pages_id
        if (isset($this->input->get->pages_id)) {
            $query_string = $this->parseQueryString([
                'pages_id' => null,
            ]);
            $href = $query_string ? "?{$query_string}" : "./";
            $markup .= "<p>" . $this->_('Displaying results for one page only.') . " "
                     . "<a class='ajax' href='{$href}'>" . $this->_('Clear page filter.') . "</a></p>";
        }

        // bail out early if there's no markup to render
        if (empty($markup)) {
            return '';
        }

        /** @var InputfieldForm */
        $form = $this->modules->get('InputfieldForm');
        $form->attr('id', 'filters');
        $form->attr('method', 'get');

        /** @var InputfieldFieldset */
        $fieldset = $this->modules->get('InputfieldFieldset');
        $fieldset->label = $this->_('Filters');
        $fieldset->icon = 'filter';

        /** @var InputfieldMarkup */
        $field = $this->modules->get('InputfieldMarkup');
        $field->markupText = '<div class="filters">' . $markup . '</div>';
        $fieldset->append($field);
        $form->append($fieldset);

        return $form->render();
    }

    /**
     * Render markup for select element
     *
     * @param string $name
     * @param string $label
     * @param array $options
     * @param array $settings
     * @return string
     */
    private function renderSelect(string $name, string $label, array $options, array $settings = []): string {

        if (!$name || isset($this->available_filters[$name]) && !in_array($name, $this->visible_filters)) {
            return '';
        }

        $disabled = "";
        if (count($options) < 2) {
            $disabled = " disabled";
        }

        $attrs = "";
        if (isset($settings['attrs'])) {
            foreach ($settings['attrs'] as $k => $v) {
                $attrs .= " {$k}='{$v}'";
            }
        }

        $markup = "";
        foreach ($options as $key => $option) {
            $value = $key ? $option : '';
            $text = !is_numeric($key) ? $key : $option;
            if (isset($settings['translate'])) {
                // phrase "deleted" is used in multiple contexts
                $text = $text == "deleted"
                    ? _x($text, $name)
                    : $this->_($text);
            }
            $selected = "";
            if ($this->input->get->$name == "!" . $value) {
                $markup .= "<option selected='selected' value='!{$value}'>" . $this->_('not') . " {$text}</option>";
            } else if ($this->input->get->$name == $value) {
                $selected = ' selected="selected"';
            }
            $markup .= "<option{$selected} value='{$value}'>{$text}</option>";
        }

        return "<label class='filter'{$disabled}>"
            . "<i class='icon icon--before' aria-hidden='true'></i>"
            . "<span class='visually-hidden'>{$label}</span>"
            . "<select name='{$name}'{$disabled}{$attrs}>{$markup}</select>"
            . "<i class='icon icon--after' aria-hidden='true'></i>"
            . "</label>";
    }

    /**
     * Fetch template data from cache
     *
     * If cache doesn't yet contain data for requested template, fill it in now and return newly stored data.
     *
     * @param string|null $name Name of template
     * @param int|null $id ID of template
     * @return array|null Template data
     */
    private function getCacheTemplate($name = null, $id = null): ?array {
        $key = $id ? "[" . (int) $id . "]" : $name;
        if (!$key) return null;
        $template_data = isset($this->template_cache[$key]) ? $this->template_cache[$key] : null;
        if (!$template_data) {
            $id = $id ? (int) $id : null;
            $name = $name ? $this->sanitizer->pageName($name) : null;
            $template = $this->templates->get($id ? $id : "name={$name}");
            if ($template && $template->id) {
                $template_data = [
                    'id' => $template->id,
                    'name' => $template->name,
                    'label' => $template->get('label|name'),
                ];
            } else {
                $where = $id ? "templates_id = {$id}" : "data LIKE '%\"Template name\":\"{$name}\"%'";
                $sql = "SELECT data, templates_id FROM " . self::TABLE_NAME . " WHERE {$where} LIMIT 1";
                $stmt = $this->database->prepare($sql);
                $stmt->execute();
                if ($stmt->rowCount()) {
                    $row = $stmt->fetch(\PDO::FETCH_ASSOC);
                    $data = json_decode($row['data'], true);
                    $template_name = isset($data['Template name']) ? $data['Template name'] : "[{$row['templates_id']}]";
                    $template_data = [
                        'id' => $row['templates_id'],
                        'name' => $template_name,
                        'label' => $template_name,
                    ];
                }
            }
            if (is_array($template_data)) {
                $this->template_cache[$template_data['name']] = $template_data;
                $this->template_cache[$template_data['id']] = $template_data;
            }
        }
        return $template_data;
    }

    /**
     * Called only when this module is installed
     *
     * Creates new page with this Process module assigned.
     */
    public function ___install() {

        // create a page for this module
        $page = $this->wire(new Page());
        $page->template = 'admin';
        $page->name = self::PAGE_NAME;
        $page->process = $this;

        // insert page under setup at admin
        $page->parent = $this->pages->get($this->config->adminRootPageID)->child('name=setup, include=all');

        // make page title match module title
        $info = self::getModuleInfo();
        $page->title = $info['title'];

        // save the page
        $page->save();

        // tell user that we've created a new page
        $this->message("Created Page: {$page->path}");

        // create changelog permission
        $permission = $this->permissions->get("changelog");
        if (!$permission->id) {
            $permission = $this->wire(new Permission());
            $permission->name = "changelog";
            $permission->title = $this->_("Access changelog");
            $permission->save();
            $this->message("Created Permission: {$permission->name}");
        }
    }

    /**
     * Called only when this module is uninstalled
     *
     * Removes page associated with this Process module.
     */
    public function ___uninstall() {

        // find the page we installed, locating it by the process field (which has the module ID)
        // it would probably be sufficient just to locate by name, but this is just to be extra sure.
        $moduleID = $this->modules->getModuleID($this);
        $page = $this->pages->get("template=admin, process={$moduleID}, name=" . self::PAGE_NAME);

        if ($page->id) {
            // if we found the page, let the user know and delete it
            $this->message("Deleting Page: {$page->path}");
            $page->delete();
        }

        // delete changelog permission
        $permission = $this->permissions->get("changelog");
        if ($permission->id) {
            $this->message("Deleting Permission: {$permission->name}");
            $permission->delete();
        }
    }

}
