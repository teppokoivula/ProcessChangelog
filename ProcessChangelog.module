<?php

/**
 * Process Changelog
 *
 * This module keeps track of changes (edits, additions, removals etc.) on
 * pages of your site. For detailed information, installation instructions
 * etc. see README.md.
 *
 * @copyright 2013-2019 Teppo Koivula
 * @license https://www.gnu.org/licenses/gpl-2.0.txt GNU General Public License, version 2
 */ 
class ProcessChangelog extends Process implements ConfigurableModule {
    
    /**
     * Return information about this module (required)
     *
     * @return array
     */
    public static function getModuleInfo() {
        return [
            'title' => __('Changelog'),
            'summary' => __('Keep track of changes (edits, removals, additions etc.)'),
            'href' => 'https://modules.processwire.com/modules/process-changelog/',
            'author' => 'Teppo Koivula',
            'version' => '1.7.1',
            'singular' => true,
            'autoload' => false,
            'icon' => 'code-fork',
            'permission' => 'changelog',
            'requires' => 'PHP>=5.4',
            'installs' => 'ProcessChangelogHooks',
        ];
    }
    
    /**
     * Default configuration for this module
     *
     * The point of putting this in it's own function is so that you don't have to specify
     * these defaults more than once.
     *
     * @return array
     */
    static public function getDefaultData() {
        return [
            'row_limit' => 25,
            'row_label' => 'name',
            'date_format' => 'Y-m-d H:i:s',
            'visible_filters' => [
                'operation',
                'username',
                'when',
                'date_range'
            ],
            'available_filters' => [
                'operation' => [
                    'label' => __("Operation"),
                    'options' => [
                        __("All operations"),
                    ],
                    'translate' => true,
                ],
                'template' => [
                    'label' => __("Template"),
                    'options' => [],
                    'translate' => false,
                ],
                'flags' => [
                    'label' => __("Flags"),
                    'options' => [
                        __("with any flags"),
                        __("with system flag") => 'System',
                        __("without system flag") => '!System'
                    ],
                    'translate' => false,
                ],
                'username' => [
                    'label' => __("Username"),
                    'options' => [],
                    'translate' => false,
                ],
                'when' => [
                    'label' => __("When"),
                    'options' => [
                        __("whenever"),
                        __("within a day") => '1 DAY',
                        __("within a week") => '1 WEEK',
                        __("within a month") => '1 MONTH',
                        __("within a year") => '1 YEAR'
                    ],
                    'translate' => false,
                ],
                'date_range' => [
                    'label' => __("Date range"),
                    'options' => [],
                    'translate' => false,
                ],
            ],
            'rss_content_type' => 0,
        ];
    }
    
    /**
     * Name of the admin page related to this module
     * 
     * @var string
     */
    const PAGE_NAME = 'changelog';
    
    /**
     * Valid Content-Type headers for the RSS feed
     * 
     * @var array
     */
    public static $rss_content_types = [
        0 => 'application/rss+xml',
        1 => 'application/xml',
        2 => 'text/xml',
    ];

    /**
     * Name of the database table used by this module
     * 
     * @var string
     */
    protected $table_name;

    /**
     * Array of operations being logged
     * 
     * @var array
     */
    protected $operations = [];

    /**
     * Array of template IDs, names and labels for caching purposes
     * 
     * @var array
     */
    protected $template_cache = [];

    /**
     * Array of optional permissions
     * 
     * - If "changelog-remove" exists, user has to have it in order to
     *   remove rows. If not, every user with access to this module can
     *   also remove rows.
     * 
     * @var array
     */
    protected $optional_permissions = [];

    /**
     * Populate the default config data
     *
     * ProcessWire will automatically overwrite it with anything the user has specifically configured.
     * This is done in construct() rather than init() because ProcessWire populates config data after
     * construct(), but before init().
     */
    public function __construct() {
        // ProcessChangelogHooks module settings define which operations are
        // logged and the name of the database table they get stored into
        if ($this->modules->isInstalled("ProcessChangelogHooks")) {
            $config = $this->modules->getModuleConfigData("ProcessChangelogHooks");
            $defaults = $this->modules->get("ProcessChangelogHooks")->getDefaultData();
            $this->table_name = ProcessChangelogHooks::TABLE_NAME;
            $this->available_operations = $defaults['operations'];
            $this->operations = isset($config['operations']) ? array_combine($config['operations'], $config['operations']) : $defaults['operations'];
        }
        foreach (self::getDefaultData() as $key => $value) {
            if ($key == "available_filters") {
                // construct list of operations (done here so that we have
                // access to settings of ProcessChangelogHooks module.)
                $value['operation']['options'] = array_merge(
                    $value['operation']['options'], 
                    $this->operations
                );
            }
            $this->$key = $value;
        }
        $this->optional_permissions = [
            'remove' => $this->permissions->get('changelog-remove'),
        ];
    }

    /**
     * Module configuration
     *
     * @param array $data
     * @return InputfieldWrapper
     */
    static public function getModuleConfigInputfields(array $data) {

        // this is a container for fields, basically like a fieldset
        $fields = new InputfieldWrapper();

        // since this is a static function, we can't use $this->modules, so get them from the global wire() function
        $modules = wire('modules');

        // merge local default settings and settings from hooks module (custom values overwrite defaults)
        $operations = [];
        if ($modules->isInstalled('ProcessChangelogHooks')) {
            $config = $modules->getModuleConfigData('ProcessChangelogHooks');
            if (isset($config['operations'])) {
                $operations = $config['operations'];
            } else {
                $operations = $modules->get('ProcessChangelogHooks')->getDefaultData()['operations'];
            }
        }
        $defaults = self::getDefaultData();
        $defaults['available_filters']['operation']['options'] = array_merge(
            $defaults['available_filters']['operation']['options'],
            $operations
        );
        $data = array_merge($defaults, $data);

        // date format used
        $field = $modules->get("InputfieldText");
        $field->name = "date_format";
        $field->label = __("Date Format");
        $field->notes = sprintf(__("See the %s function reference for more information on how to customize this format."), "[PHP date](http://www.php.net/manual/en/function.date.php)"); // Date format notes // %s will be replaced by a link to date section of PHP manual run-time
        $field->value = $data['date_format'] ? $data['date_format'] : $defaults['date_format'];
        $fields->add($field);

        // number of results visible at once
        $field = $modules->get("InputfieldSelect");
        $field->name = "row_limit";
        $field->label = __("Row Limit");
        $field->description = __("Number of rows visible at once");
        $field->required = true;
        $field->addOptions([
            25 => '25', 
            50 => '50', 
            75 => '75', 
            100 => '100',
        ]);
        $field->value = $data['row_limit'];
        $fields->add($field);

        // field to use as row label
        $field = $modules->get("InputfieldSelect");
        $field->name = "row_label";
        $field->label = __("Row Label");
        $field->description = __("Which field should be used as row label?");
        $field->required = true;
        $field->addOptions([
            'name' => __("Page name"),
            'url' => __("Page URL"),
        ]);
        $field->value = $data['row_label'];
        $fields->add($field);

        // visibility settings, grouped together by fieldset
        $fieldset_visibility = $modules->get("InputfieldFieldset");
        $fieldset_visibility->label = __("Visibility settings");
        $fieldset_visibility->collapsed = true;

        // visible filters
        $field = $modules->get("InputfieldCheckboxes");
        $field->name = "visible_filters";
        $field->label = __("Visible filters");
        $field->notes = __("Unchecking all filters completely hides filters area.");
        foreach ($data['available_filters'] as $name => $filter) {
            $field->addOption($name, $filter['label']);
        }
        $field->value = $data['visible_filters'];
        $fieldset_visibility->add($field);

        // values for hidden filters
        $fieldset = $modules->get("InputfieldFieldset");
        $fieldset->label = __("Values for hidden filters");
        $fieldset->notes = __("Filters not listed here are ignored when hidden.");
        foreach ($data['available_filters'] as $name => $filter) {
            if (!$filter['options']) continue;
            $field = $modules->get("InputfieldSelect");
            $field->name = 'default_for_' . $name;
            $field->label = $filter['label'];
            foreach ($filter['options'] as $key => $option) {
                $value = $key ? $option : '';
                $text = !is_numeric($key) ? $key : $option;
                if ($filter['translate']) {
                    if ($text == "deleted" && $name == "operation") {
                        // "deleted" is used in multiple contexts
                        $text = _x($text, $name);
                    } else {
                        $text = __($text);
                    }
                }
                $field->addOption($value, $text);
            }
            if (isset($data['default_for_' . $name])) {
                $field->value = $data['default_for_' . $name];
            }
            $fieldset->add($field);
        }
        $fieldset_visibility->add($fieldset);

        $fields->add($fieldset_visibility);
        
        // RSS settings
        $fieldset_rss = $modules->get("InputfieldFieldset");
        $fieldset_rss->label = __("RSS settings");
        $fieldset_rss->collapsed = true;
        
        // RSS Content-Type header
        $field = $modules->get("InputfieldSelect");
        $field->name = "rss_content_type";
        $field->addOptions(self::$rss_content_types);
        $field->value = $data['rss_content_type'];
        $fieldset_rss->add($field);
        
        $fields->add($fieldset_rss);

        return $fields;
    }

    /**
     * Initialization function called before any execute functions
     */
    public function init() {
        parent::init();
        if (count(array_intersect(['operation', 'template', 'flags'], $this->visible_filters)) > 1) {
            $available_filters = $this->available_filters;
            $available_filters['operation']['options'] = array_merge(
                [__("All operations on")],
                $this->operations
            );
            $this->available_filters = $available_filters;
        }
        // should date formatting occur?
        $defaults = self::getDefaultData();
        if ($this->date_format == $defaults['date_format']) {
            unset($this->date_format);
        }
        // take values for hidden filters into account
        $hidden_filters = array_diff(array_keys($this->available_filters), $this->visible_filters);
        foreach ($hidden_filters as $filter) {
            $this->input->get->$filter = $this->get("default_for_$filter");
        }
    }

    /**
     * Executed when a page with this Process assigned is accessed
     *
     * @return string
     */
    public function ___execute() {
        
        // make sure that we have a newish version of Font-Awesome loaded
        if (version_compare($this->config->version, '3.0.18', '<')) {
            $this->config->styles->add('//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css');
        }
        
        // render filters (this has to be done here because certain filter
        // choices may affect choices available when building SQL queries)
        $filters = $this->renderFilters();
        
        // setup admin data table
        $table = $this->modules->get("MarkupAdminDataTable");
        $table->setEncodeEntities(false);
        $table->setClass('log');
        $table->headerRow([
            __('When'),
            __('Who'),
            __('What'),
            __('Remove'),
            __('More')
        ]);
        
        // fetch rows from database and add them to our data table
        $query = $this->buildQuery();
        $stmt = $this->database->prepare($query['query']); 
        $stmt->execute();
        while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
            $table->row($this->parseTableRow($row));
        }

        // if less than two matches were found, disable table sorting
        if ($query['total'] < 2) $table->setSortable(false);
        
        // pager markup
        $pager = "";
        if ($query['limit'] && $query['total'] > $query['limit']) {
            $pager_links = 20;
            $pager_page = (int) $query['start']/$query['limit']+1;
            $pager_pages = ceil($query['total']/$query['limit']);
            $pager = $this->renderPager($pager_links, $pager_page, $pager_pages);
        }
        
        // UI translations
        $this->config->js('log', [
            'i18n' => [
                'more' => __("more"),
                'less' => __("less"),
                'areYouSure' => __("Are you sure?"),
                'removeFailed' => __("Sorry, remove failed"),
            ],
        ]);
        
        // basic information about found rows
        $info = "<div id='info'><h2>";
        $info .= sprintf(_n("One matching row found.", "%d matching rows found.", $query['total']), $query['total']);
        $info .= "</h2></div>";
        
        // feed links
        $feeds = "<ul id='feeds'>";
        $feeds .= "<li><a href='./rss/' target='_blank'>" . __('RSS') . "</a></li>";
        if ($this->modules->isInstalled('ProcessChangelogRSS')) {
            $changelogRSS = $this->modules->get('ProcessChangelogRSS');
            if ($changelogRSS->feed_url && $changelogRSS->show_feed_link) {
                $feeds .= "<li><a href='{$changelogRSS->feed_url}' target='_blank'>" . __('Public RSS') . "</a></li>";
            }
        }
        $feeds .= "</ul>";
        
        // return admin data table markup and pager
        return $filters . $info . $table->render() . $pager . $feeds;
        
    }

    /**
     * Executed when a page with this Process assigned is accessed with /JSON/
     *
     */
    public function ___executeJSON() {

        // fetch rows from database
        $data = [];
        $query = $this->buildQuery();
        $stmt = $this->database->prepare($query['query']);
        $stmt->execute();
        while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) $data[] = $row;

        // send header and output JSON
        header('Content-type: application/json');
        exit(json_encode($data));

    }

    /**
     * Executed when a page with this Process assigned is accessed with /RSS/
     *
     */
    public function ___executeRSS() {
        
        // create rss element
        $rss = new SimpleXMLElement('<rss/>');
        $rss->addAttribute('version', '2.0');

        // create channel eelment
        $channel = $rss->addChild('channel');
        $channel->addChild('title', __('Changelog'));
        $channel->addChild('link', $this->input->httpUrl . ($_GET ? '?' . htmlentities($this->input->queryString) : ''));
        $channel->addChild('description', __('An automatically generated changelog for this site.'));
        
        // fetch rows from database
        $data = [];
        $query = $this->buildQuery();
        $stmt = $this->database->prepare($query['query']);
        $stmt->execute();
        while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
            $item = $channel->addChild('item');
            $item->addChild('title', $this->parseString($row));
            if ($row['data']) {
                $details = json_decode($row['data'], true);
                $item->addChild('description', $this->renderDetails($row['operation'], $details));
            } else {
                $item->addChild('description', __("No data available."));
            }
            $item->addChild('link', 'http' . ($this->config->https ? 's' : '') . '://' . $this->config->httpHost . $this->config->urls->admin . 'page/edit/?id=' . (int) $row['pages_id']);
            $item->addChild('pubDate', date(DATE_RSS, strtotime($row['timestamp'])));
        }

        // send header and output RSS
        if (((int) $this->rss_content_type != $this->rss_content_type) || !isset(self::$rss_content_types[$this->rss_content_type])) {
            $this->rss_content_type = 0;
        };
        header('Content-type: ' . self::$rss_content_types[$this->rss_content_type] . '; charset=UTF-8');
        exit($rss->asXML());

    }

    /**
     * Build SQL query for fetching changelog data from custom database table
     *
     * @param array $group_by Fields to group results by, such as "id"
     * @return array Array with SQL query ('query'), total row count ('total'),
     *         start ('start') and limit ('limit')
     * @throws WireException if template data can't be found
     * @throws WireException if template flag is not recognized
     */
    private function buildQuery(array $group_by = []) {

        // $joins and $where arrays are used to construct where clause and joins
        // later. $where contains rules like "key = '$value'" and $joins actual
        // joins, such as "LEFT JOIN table ON table.id = $id".
        $joins = [];
        $where = [];

        // Allowed keys (GET params used to build queries) are defined here to
        // make sure we're not letting any weird queries get past us.
        $allowed_keys = [
            "id",
            "template",
            "flags",
            "user_id",
            "username",
            "pages_id",
            "operation",
            "when",
            "date_from",
            "date_until",
        ];

        // Possible values for 'when' filter
        $allowed_intervals = array_values(
            $this->available_filters['when']['options']
        );

        foreach ($this->input->get as $key => $value) {
            if (in_array($key, $allowed_keys) && $value != "") {
                $operator = "=";
                $value = $this->database->escapeStr($value);
                if (strpos($value, "!") === 0) {
                    $operator = "!=";
                    $value = substr($value, 1);
                }
                switch ($key) {
                    case "data":
                        $where[] = "{$key} LIKE '%{$value}%'";
                        break;
                    case "when":
                        if (!isset($where['date_from']) && !isset($where['date_until']) && in_array($value, $allowed_intervals)) {
                            $where[$key] = "DATE_SUB(CURDATE(), INTERVAL {$value}) <= timestamp";
                        }
                        break;
                    case "date_from":
                    case "date_until":
                        if (!isset($where['when'])) {
                            $value = date("Y-m-d", strtotime($value));
                            $operator = "<=";
                            $time = "23:59";
                            if ($key == "date_from") {
                                $operator = ">=";
                                $time = "00:00";
                            }
                            $where[$key] = "timestamp {$operator} '{$value} {$time}'";
                        }
                        break;
                    case "template":
                        $join = "LEFT OUTER JOIN pages ON pages.id = {$this->table_name}.pages_id";
                        if (!in_array($join, $joins)) $joins[] = $join;
                        $template = $this->getCacheTemplate($value);
                        if ($template) {
                            $where[] = "(pages.templates_id {$operator} {$template['id']}"
                                     . " OR {$this->table_name}.templates_id {$operator} {$template['id']})";
                        } else {
                            throw new WireException(sprintf(__("Template not found: %s"), $this->sanitizer->pageName($value)));
                        }
                        break;
                    case "flags":
                        $join = "LEFT OUTER JOIN pages ON pages.id = {$this->table_name}.pages_id";
                        if (!in_array($join, $joins)) $joins[] = $join;
                        $joins[] = "JOIN templates ON templates.id IN(pages.templates_id, {$this->table_name}.templates_id)";
                        if ($flag = constant("Template::flag$value") ?: constant("\ProcessWire\Template::flag$value")) {
                            // since this is a bitwise operation, we need to
                            // modify our operator logic.. a bit
                            $negation = strpos($operator, "!") === 0;
                            $where[] = "templates.flags & " . (int) $flag;
                            if ($negation) $where[count($where)-1] = "NOT(" . $where[count($where)-1] . ")";
                        } else {
                            throw new WireException(sprintf(__("Flag not supported: %s"), $value)); 
                        }
                        break;
                    case "operation":
                        if (!in_array($value, array_flip($this->operations))) {
                            unset($this->input->get->$key);
                            break;
                        }
                    default:
                        $where[] = "{$key} {$operator} '{$value}'";
                }
            }
        }
        
        // make sure that only operations being currently logged are visible,
        // even after selecting "all operations"
        if (!$this->input->get->operation && $this->operations != $this->available_operations) {
            $value = $this->database->escapeStr(implode(",", $this->operations));
            $where[] = "operation IN('" . str_replace(",", "','", $value) . "')";
        }
        
        // put together WHERE clause, required JOINs and GROUP BY
        $where = $where ? "WHERE " . implode(" AND ", $where) : "";
        $joins = $joins ? " " . implode(" ", $joins) : "";
        $group_by = $group_by ? "GROUP BY " . implode(", ", $group_by) : "";
        
        // total count of rows in database table
        $count = $group_by ? "DISTINCT " . substr($group_by, 9) : "*";
        $sql = "SELECT COUNT({$count}) FROM {$this->table_name} {$joins} {$where}";
        $stmt = $this->database->prepare($sql); 
        $stmt->execute();
        $row = $stmt->fetch(PDO::FETCH_NUM);
        $total = reset($row);
        
        // put together LIMIT
        $start = 0;
        $limit = isset($this->input->get->limit) ? (int) $this->input->get->limit : $this->row_limit;
        if ($limit && $total > $limit) {
            if ($this->input->get->page) $start = ($this->input->get->page-1)*$limit;
            if ($start > $total) $start = $total-$limit;
        }
        
        // put together ORDER BY
        $sort = "";
        $order_by = "ORDER BY ";
        if ($this->input->get->sort) {
            $sort_fields = [
                'id',
                'user_id',
                'username',
                'pages_id',
                'templates_id',
                'operation',
                'timestamp',
            ];
            if (in_array(ltrim($this->input->get->sort, '-'), $sort_fields)) {
                $sort = $this->input->get->sort;
                $sort_order = strpos($sort, "-") === 0 ? "DESC" : "ASC";
                if ($sort_order == "DESC") $sort = substr($sort, 1);
                if ($sort == "timestamp") $sort = "id";
                $sort = $this->database->escapeStr($sort);
                $order_by .= "{$sort} {$sort_order}";
                if ($sort != "id") $order_by .= ", ";
            }
        }
        if ($sort != "id") $order_by .= "id DESC";
        
        // stick pieces together to construct final SQL query
        $query = "SELECT {$this->table_name}.* FROM {$this->table_name} {$joins} {$where} {$group_by} {$order_by}";
        if ($limit) $query .= " LIMIT {$start}, {$limit}";
        
        // return SQL query along with some additional data
        return [
            'query' => $query,
            'total' => $total,
            'start' => $start,
            'limit' => $limit,
        ];

    }

    /**
     * Parse MarkupAdminDataTable row from a row fetched from database
     *
     * @param array $row
     * @return array
     */
    private function parseTableRow(array $row) {

        // container
        $data = [];
            
        // escape values (just a precaution really)
        foreach ($row as $key => $value) {
            if ($key != "data") $row[$key] = htmlentities($value);
        }

        // timestamp (raw timestamp is hidden and only included to allow proper sorting with JavaScript)
        $date = $this->date_format ? date($this->date_format, strtotime($row['timestamp'])) : $row['timestamp'];
        $data[] = "<span hidden>{$row['timestamp']}</span>{$date}";

        // username
        $selected = $this->input->get->username == $row['username'] ? ' selected' : '';
        $query_string = $this->parseQueryString([
            'username' => $selected ? null : $row['username'],
        ]);
        $filter = " <a class='ajax action{$selected}' href='?{$query_string}'><i class='fa fa-filter'></i></a>";
        if ($row['username'] == 'guest') {
            // guest user, no need to show an edit link
            $data[] = "<span class='user guest'>" . __('guest') . "</span>{$filter}";
        } else {
            // check if user still exists and if yes, provide an edit link
            $user = $this->users->get((int) $row['user_id']);
            if ($user->id) {
                $data[] = "<a class='user' href='{$this->config->urls->admin}access/users/edit/?id={$user->id}'>{$user->name}</a>{$filter}";
            } else {
                $data[] = "<span class='user deleted' title='" . __("deleted") . "'>{$row['username']}</span>{$filter}";
            }
        }

        // translatable operations
        // __('added')
        // __('moved')
        // __('edited')
        // __('trashed')
        // __('renamed')
        // _x('deleted', 'operation')
        // __('restored')
        // __('published')
        // __('unpublished')

        // variables we're going to need later
        $target = "";
        $template = "";
        $operation = $row['operation'];
        $page = $this->pages->get($row['pages_id']);
        $details = json_decode($row['data'], true);
        $key = $this->row_label == 'url' ? 'page URL' : 'page name';

        // start putting together human-readable version of what happened
        switch ($operation) {
            case 'renamed':
                $target .= "<span class='page'>" . $details["Previous $key"] . "</span>"
                        . " <strong>" . __("as") . "</strong>" // as // In context of a rename operation ("renamed old-page-name as new-page-name")
                        . " <span class='page'>" . $details[ucfirst($key)] . "</span>";
                break;
            case 'trashed':
                $target .= "<span class='page'>" . $details["Previous $key"] . " <i class='fa fa-arrow-right'></i> " . $details[ucfirst($key)] . "</span>";
                break;
            default:
                $target .= "<span class='page'>" . $details[ucfirst($key)] . "</span>";
        }

        if ($page->id) {
            $template = $page->template;
            if ($page->editable()) {
                // append edit link to target
                $href = "{$this->config->urls->admin}page/edit/?id={$page->id}";
                $target .= " &nbsp; <a class='action edit-page' href='{$href}'>" . __('edit page') . "</a>";
            }
        } else if ($row['templates_id']) {
            $template = $this->templates->get((int) $row["templates_id"]);
        }

        if ($template) {
            $template_icons = "";
            if ($template->flags & Template::flagSystem) {
                $template_icons .= " <i class='fa fa-gear' title='" . __("System template") . "'></i>";
            }
            $template_label = $template->label ? $template->label : $template;
            if (in_array('template', $this->visible_filters)) {
                $selected = $this->input->get->template == $template->name ? ' selected' : '';
                $query_string = $this->parseQueryString([
                    'template' => $selected ? '' : $template->name,
                ]);
                $template = "<a class='ajax tag template{$selected}' href='?{$query_string}'>{$template_label}{$template_icons}</a> ";
            } else {
                $template = "<strong class='template'>{$template_label}{$template_icons}</strong> ";
            }
        } else {
            // template is unknown or has been deleted
            $template = "<strong class='deleted'>" . __('deleted') . "</strong>";
        }

        // "deleted" is only phrase used in multiple contexts
        if ($operation != 'deleted') $operation_i18n = __($operation);
        else $operation_i18n = _x($operation, 'operation');

        $selected = $this->input->get->operation == $operation ? ' selected' : '';
        $query_string = $this->parseQueryString([
            'operation' => $selected ? '' : $operation,
        ]);
        $data[] = "<a class='ajax tag{$selected}' href='?{$query_string}'>{$operation_i18n}</a> {$template} {$target}";

        // link for removing individual row
        if (!$this->optional_permissions['remove']->id || $this->user->hasPermission($this->optional_permissions['remove'])) {
            $data[] = "<a href='./delete/?id={$row['id']}' class='action remove-row'>" . __("remove?") . "</a>";
        } else {
            $data[] = "";
        }

        // more details about page in question
        $data[] = $details ? $this->renderDetails($operation, $details) : __("No data available.");

        return $data;

    }

    /**
     * Parse query string based on GET variables and provided additional arguments
     *
     * @param array $args Additional arguments
     * @return string
     */
    private function parseQueryString(array $args = []) {
        return htmlentities(
            http_build_query(
                array_merge(
                    $this->input->get->getArray(),
                    $args
                )
            )
        );
    }

    /**
     * Parse string from a row fetched from database
     *
     * @param array $row
     * @return string
     */
    private function parseString(array $row) {

        $out = [];
        
        // escape values (just a precaution really)
        foreach ($row as $key => $value) {
            if ($key != "data") $row[$key] = htmlentities($value);
        }

        // user
        $user = $this->users->get($row['user_id']);
        $out[] = $user->id ? $user->name : $row['username'] . " (" . __("deleted") . ")";

        // operation
        $operation_i18n = __($row['operation']);
        if ($row['operation'] == "deleted") $operation_i18n = _x($row['operation'], 'operation');
        $out[] = $operation_i18n;
        
        // template
        $template = "";
        $page = $this->pages->get($row['pages_id']);
        if ($page->id) {
            $template = $page->template;
        } else if ($row["templates_id"] && $this->templates->get($row["templates_id"])) {
            $template = $this->templates->get($row["templates_id"]);
        }
        $out[] = $template ? ($template->label ?: $template) : __("Page");
        
        // target
        $details = json_decode($row['data'], true);
        $key = $this->row_label == 'url' ? 'page URL' : 'page name';
        switch ($row['operation']) {
            case 'renamed':
                $out[] = $details["Previous $key"] . " " . __("as") . " " . $details[ucfirst($key)];
                break;
            case 'trashed':
                $out[] = $details["Previous $key"] . " (" . $details[ucfirst($key)] . ")";
                break;
            default:
                $out[] = $details[ucfirst($key)];
        }

        return implode(" ", $out);

    }

    /**
     * Render markup for pager
     *
     * @param int $links Number of pager links visible at once
     * @param int $page Identifies currently active pager item
     * @param int $pages Number of total pager items available
     * @return string
     */
    private function renderPager($links, $page, $pages) {

        if ($pages < 2) return;

        // convert GET params to string
        $get = "";
        foreach ($this->input->get as $key => $value) {
            if ($key != "page" && $value != "") {
                $get .= "&amp;" . urlencode($key) . "=" . urlencode($value);
            }
        }

        // calculate start and end points
        $start = 1;
        $end = $pages;
        if ($end > $links) {
            $start = (int) $page - $links / 2;
            if ($start < 1) $start = 1;
            $end = $start + ($links - 1);
            if ($end > $pages) $end = $pages;
            if ($end - $page < (int) $links / 2 - 1) { 
                $start -= ((int) $links / 2) - ($end - $page);
                if ($start < 1) $start = 1;
            }
        }

        // generate markup
        $out = "";
        $pager_config = $this->config->MarkupPagerNav ?: [
            'currentItemClass' => 'uk-active MarkupPagerNavOn',
            'separatorItemLabel' => '<span>&hellip;</span>',
            'separatorItemClass' => 'uk-disabled MarkupPagerNavSeparator',
            'listMarkup' => "<ul class='uk-pagination MarkupPagerNav'>{out}</ul>",
        ];
        if ($start > 1) {
            $out .= "<li><a href='./?page=1{$get}'><span>1</span></a></li>";
            if ($start > 2) {
                $out .= "<li class='{$pager_config['separatorItemClass']}'>{$pager_config['separatorItemLabel']}</li>";
            }
        }
        for ($i = $start; $i <= $pages; ++$i) {
            $here = $page == $i ? " class='{$pager_config['currentItemClass']}'" : "";
            $out .= "<li{$here}><a href='./?page={$i}{$get}'><span>{$i}</span></a></li>";
            if ($pages > $links && $i == $end && $i < $pages) {
                if ($pages - $i > 1) {
                    $out .= "<li class='{$pager_config['separatorItemClass']}'>{$pager_config['separatorItemLabel']}</li>";
                }
                $i = $pages-1;
                if ($i < $end) $i = $end + 1;
            }
        }
        $out = str_replace(
            '{out}',
            $out,
            $pager_config['listMarkup']
        );
        
        return "<div class='MarkupPagerNavCustom'>{$out}</div>";

    }

    /**
     * Render human readable view of row details
     *
     * @param string $operation
     * @param array $details
     * @return string
     */
    private function renderDetails($operation = null, $details = []) {

        // action details are required
        if (!$details) return false;

        // init vars
        $markup = "";
        $class = $operation ? " icon-{$operation}" : "";

        // translatable phrases
        // __('Previous page name')
        // __('Current page name')
        // __('Page name')
        // __('Page title')
        // __('Parent page')
        // __('Previous parent page')
        // __('Page URL')
        // __('Previous URL')
        // __('Current URL')
        // __('Fields edited')
        // __('Caller')

        foreach ($details as $key => $value) {
            // escape key and value
            $key = htmlentities($key);
            $value = htmlentities($value);
            // generate markup
            $markup .= "<tr><th>" . __($key) . "</th><td>{$value}</td></tr>";
        }
        
        return "<table class='details{$class}'>{$markup}</table>";

    }

    /**
     * Executed when requesting removal of an individual row
     * 
     * @return boolean
     * @throws WirePermissionException if changelog-remove permission exists
     *         but the current user doesn't have it.
     */
    public function ___executeDelete() {
        if (!$this->optional_permissions['remove']->id || $this->user->hasPermission($this->optional_permissions['remove'])) {
            if ((int) $this->input->get->id != $this->input->get->id) return false;
            $id = (int) $this->input->get->id;
            $sql = "DELETE FROM {$this->table_name} WHERE id=:id LIMIT 1";
            $stmt = $this->database->prepare($sql); 
            $stmt->bindValue(':id', $id, PDO::PARAM_INT); 
            $stmt->execute();
            return 1;
        } else {
            throw new WirePermissionException(__("You do not have the permission required by this action."));
        }
    }

    /**
     * Render markup for result filter UI
     *
     * @return string 
     */
    private function renderFilters() {

        $markup = "";

        // operations
        $markup .= $this->renderSelect(
            'operation',
            array_flip($this->available_filters['operation']['options'])
        );

        // templates
        if (in_array('template', $this->visible_filters)) {
            $options = [];
            $join_flags = "";
            if ($this->input->get->flags) {
                $flag = str_replace("_", "", $this->sanitizer->name($this->input->get->flags));
                if (constant("Template::flag{$flag}")) {
                    $and_on = "templates.flags & " . constant("Template::flag{$flag}");
                    if (strpos($this->input->get->flags, "!") === 0) $and_on = "NOT({$and_on})";
                    $join_flags .= "JOIN templates "
                                 . "ON templates.id = {$this->table_name}.templates_id "
                                 . "AND {$and_on}";
                }
            }
            $sql = "SELECT DISTINCT {$this->table_name}.templates_id FROM {$this->table_name} {$join_flags}";
            $stmt = $this->database->prepare($sql); 
            $stmt->execute(); 
            $rowCount = $stmt->rowCount();
            if (!$rowCount || $rowCount > 1) {
                $options[] = __("pages");
            }
            while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
                $template = $this->getCacheTemplate(null, (int) $row['templates_id']);
                $key = sprintf(__("%s pages"), $template['label']); // %s pages // %s will be replaced run-time by template
                $options[$key] = $template['name'];
            }
            $markup .= $this->renderSelect('template', $options);
        }

        // flags
        if (in_array('flags', $this->visible_filters)) {
            $options = $this->available_filters['flags']['options'];
            if (!in_array('template', $this->visible_filters)) {
                foreach ($options as $option => $value) {
                    $new_option = $option ? __("pages ") . $option : 0; // pages // In context of flags ("pages with system flags" etc.)
                    if ($new_option) unset($options[$option]);
                    else $value = __("pages ") . $value;
                    $options[$new_option] = $value;
                }
            }
            if ($this->input->get->template) {
                // if template is set, some flag options may not be applicable
                $template = $this->sanitizer->pageName($this->input->get->template);
                $template_flags = $this->templates->get($template)->flags;
                foreach ($options as $key => $value) {
                    // note: sanitizer->name converts illegal characters (including
                    // negation operator) to underscores, which are then removed to
                    // catch possible flag names
                    $flag = str_replace("_", "", $this->sanitizer->name($value));
                    if (defined("Template::flag{$flag}")) {
                        $negation = strpos($value, "!") === 0;
                        $has_flag = $template_flags & constant("Template::flag{$flag}");
                        if ($negation && $has_flag || !$negation && !$has_flag) {
                            if ($this->input->get->flags == $options[$key]) {
                                // flag being removed from available options is
                                // used as search criteria; unset GET param too
                                unset($this->input->get->flags);
                            }
                            unset($options[$key]);
                        }
                    }
                }
                // unset "with any flags" if flags matched
                if (count($options) > 1) unset($options[0]);
            }
            $markup .= $this->renderSelect('flags', $options);
        }

        // username
        if (in_array('username', $this->visible_filters)) {
            $options = [];
            $where = "";
            if (in_array($this->input->get->operation, $this->operations)) {
                $where = " WHERE operation = '{$this->input->get->operation}'";
            } else if ($this->operations != $this->available_operations) {
                $where = " WHERE operation IN('" . implode("','", $this->operations) . "')";
            }
            $sql = "SELECT DISTINCT username 
                    FROM {$this->table_name}
                    {$where} 
                    ORDER BY username DESC";
            $stmt = $this->database->prepare($sql);
            $stmt->execute();
            $rowCount = $stmt->rowCount();
            if (!$rowCount || $rowCount > 1) {
                $options[] = __("by any user");
            }
            while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
                if ($row['username'] == "guest") {
                    $key = __("by guest");
                } else {
                    $key = sprintf(__("by %s"), $row['username']); // by %s // %s will be replaced run-time by username
                }
                if (!in_array("operation", $this->visible_filters)) {
                    $key = sprintf(__("modified %s"), $key); // modified %s // %s will be replaced run-time with "by [username]"
                }
                $options[$key] = $row['username'];
            }
            $markup .= $this->renderSelect('username', $options);
        }

        // when
        if (in_array('when', $this->visible_filters) || in_array('date_range', $this->visible_filters)) {
            $options = array();
            if (in_array('when', $this->visible_filters)) {
                $options = $this->available_filters['when']['options'];
                if (in_array('date_range', $this->visible_filters)) {
                    $options[__("between")] = "between";
                }
                $markup .= $this->renderSelect('when', $options);
            }
            
            // date range
            if (in_array('date_range', $this->visible_filters)) {
                $disabled_title = __("Not relevant in this context");
                $date_from = $this->input->get->date_from ? date('d.m.Y', strtotime($this->input->get->date_from)) : '';
                $date_until = $this->input->get->date_until ? date('d.m.Y', strtotime($this->input->get->date_until)) : '';
                $input = $this->modules->get("InputfieldText");
                $markup .= "<div class='filter no-icon'>"
                         . "<input type='text'"
                         . " value='{$date_from}'"
                         . " size='10'"
                         . " data-maxdate='+0D'"
                         . " data-dateformat='dd.mm.yy'"
                         . " name='date_from'"
                         . " data-disabled-title='{$disabled_title}'"
                         . " class='log-datepicker'"
                         . " />"
                         . "</div>"
                         . " .. "
                         . "<div class='filter no-icon'>"
                         . "<input type='text'"
                         . " value='{$date_until}'"
                         . " size='10'"
                         . " data-maxdate='+0D'"
                         . " data-dateformat='dd.mm.yy'"
                         . " name='date_until'"
                         . " class='log-datepicker'"
                         . " />"
                         . "</div>";
            }
        }

        // pages_id
        if (isset($this->input->get->pages_id)) {
            $query_string = $this->parseQueryString([
                'pages_id' => null,
            ]);
            $href = $query_string ? "?{$query_string}" : "./";
            $markup .= "<p>" . __('Displaying results for one page only.') . " "
                     . "<a class='ajax' href='{$href}'>" . __('Clear page filter.') . "</a></p>";
        }

        if ($markup) {
            $form = $this->modules->get('InputfieldForm');
            $form->attr('id', 'filters');
            $form->attr('method', 'get');
            $fieldset = $this->modules->get('InputfieldFieldset');
            $fieldset->label = __('Filters');
            $fieldset->icon = 'filter';
            $field = $this->modules->get('InputfieldMarkup');
            $field->markupText = $markup;
            $fieldset->append($field);
            $form->append($fieldset);
            return $form->render();
        }
        
    }

    /**
     * Render markup for select element
     *
     * @param string $name
     * @param array $options
     * @param array $settings
     * @return string
     */
    private function renderSelect($name, array $options, array $settings = []) {
        
        if (!$name || isset($this->available_filters[$name]) && !in_array($name, $this->visible_filters)) {
            return;
        }

        $disabled = "";
        if (count($options) < 2) {
            $disabled = " disabled='disabled' class='disabled'";
        }

        $attrs = "";
        if (isset($settings['attrs'])) {
            foreach ($settings['attrs'] as $k => $v) $attrs .= " {$k}='{$v}'";
        }

        $markup = "";
        foreach ($options as $key => $option) {
            $value = $key ? $option : '';
            $text = !is_numeric($key) ? $key : $option;
            if (isset($settings['translate'])) {
                // phrase "deleted" is used in multiple contexts
                if ($text == "deleted") $text = _x($text, $name);
                else $text = __($text);
            }
            $selected = $this->input->get->$name == $value ? ' selected="selected"' : '';
            $markup .= "<option{$selected} value='{$value}'>{$text}</option>";
        }

        return "<div class='filter'{$disabled}>"
             . "<select name='{$name}'{$disabled}{$attrs}>{$markup}</select></div>";

    }

    /**
     * Fetch template data from cache
     * 
     * If cache doesn't yet contain data for requested template, fill it in now
     * and return newly stored data.
     * 
     * @param string $name Name of template
     * @param int $id ID of template
     * @return array Template data
     */
    private function getCacheTemplate($name = null, $id = null) {
        $key = $id ? "[" . (int) $id . "]" : $name;
        if (!$key) return null;
        $template_data = isset($this->template_cache[$key]) ? $this->template_cache[$key] : null;
        if (!$template_data) {
            $id = $id ? (int) $id : null;
            $name = $name ? $this->sanitizer->pageName($name) : null;
            $template = $this->templates->get($id ? $id : "name={$name}");
            if ($template && $template->id) {
                $template_data = [
                    'id' => $template->id,
                    'name' => $template->name,
                    'label' => $template->get('label|name'),
                ];
            } else {
                $where = $id ? "templates_id = {$id}" : "data LIKE '%\"Template name\":\"{$name}\"%'";
                $sql = "SELECT data, templates_id FROM {$this->table_name} WHERE {$where} LIMIT 1";
                $stmt = $this->database->prepare($sql);
                $stmt->execute();
                if ($stmt->rowCount()) {
                    $row = $stmt->fetch(PDO::FETCH_ASSOC);
                    $data = json_decode($row['data'], true);
                    $template_name = isset($data['Template name']) ? $data['Template name'] : "[{$row['templates_id']}]";
                    $template_data = [
                        'id' => $row['templates_id'],
                        'name' => $template_name,
                        'label' => $template_name,
                    ];
                }
            }
            if (is_array($template_data)) {
                $this->template_cache[$template_data['name']] = $template_data;
                $this->template_cache[$template_data['id']] = $template_data;
            }
        }
        return $template_data;
    }

    /**
     * Called only when this module is installed
     *
     * Creates new page with this Process module assigned.
     */
    public function ___install() {

        // create a page for this module
        $page = new Page();
        $page->template = 'admin';
        $page->name = self::PAGE_NAME; 
        $page->process = $this; 

        // insert page under setup at admin
        $page->parent = $this->pages->get($this->config->adminRootPageID)->child('name=setup, include=all');

        // make page title match module title
        $info = self::getModuleInfo();
        $page->title = $info['title'];

        // save the page
        $page->save();

        // tell user that we've created a new page
        $this->message("Created Page: {$page->path}");

        // create changelog permission
        $permission = $this->permissions->get("changelog");
        if (!$permission->id) {
            $permission = new Permission();
            $permission->name = "changelog";
            $permission->title = $this->_("Access changelog");
            $permission->save();
            $this->message("Created Permission: {$permission->name}");
        }

    }

    /**
     * Called only when this module is uninstalled
     *
     * Removes page associated with this Process module.
     */
    public function ___uninstall() {

        // find the page we installed, locating it by the process field (which has the module ID)
        // it would probably be sufficient just to locate by name, but this is just to be extra sure.
        $moduleID = $this->modules->getModuleID($this); 
        $page = $this->pages->get("template=admin, process={$moduleID}, name=" . self::PAGE_NAME); 

        if($page->id) {
            // if we found the page, let the user know and delete it
            $this->message("Deleting Page: {$page->path}"); 
            $page->delete();
        }

        // delete changelog permission
        $permission = $this->permissions->get("changelog");
        if ($permission->id) {
            $this->message("Deleting Permission: {$permission->name}");
            $permission->delete();
        }

    }
    
}
